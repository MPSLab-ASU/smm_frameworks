#! /usr/bin/env python

import getopt
import os
import subprocess
import sys


# Create a makefile for a SMM architecture
def create_smm_makefile(arguments="", infile = ""):
	#  make file
	makefile = """
PROGRAM = ${program}

SMMDIR=/home/jcai/Documents/smmstack/lib

INCLUDEDIRS=
INCLUDE=
LIBDIRS=
LIBS = -lm

OBJECTS = ${original_objects}
OPT_OBJECTS = stack_manager.bc ${opt_objects}
PROF_OBJECTS = stack_management_helper.bc ${prof_objects}
CC=clang
CFLAGS = $(INCLUDEDIRS) $(INCLUDE) -emit-llvm -c -O3 -fno-inline
LDFLAGS = $(LIBDIRS) $(LIBS) -static

all: $(PROGRAM)

$(PROGRAM): $(OBJECTS)
	llvm-link -o basic_$@.bc $(OBJECTS)
	opt -O3 -disable-inlining < basic_$@.bc > $@.bc
	llvm-dis < $@.bc > $@.ll
	llc -O3 -o $@.s $@.bc 
	$(CC) -o $@ $@.s $(LDFLAGS)
	objdump -d $@ > $@.dis


%.bc: %${source_file_extension}
	$(CC) $(CFLAGS) $< -o $@

opt: $(OPT_OBJECTS)
	llvm-link -o opt_basic_$(PROGRAM).bc $(OPT_OBJECTS)
	opt -O3 -disable-inlining -load /home/jcai/Applications/llvm/build/Debug+Asserts/lib/LLVMStackManagement.so -smmsm < opt_basic_$(PROGRAM).bc > opt_$(PROGRAM).bc
	llvm-dis < opt_$(PROGRAM).bc > opt_$(PROGRAM).ll
	llc -O3 -o opt_$(PROGRAM).s opt_$(PROGRAM).bc 
	$(CC) -o opt_$(PROGRAM) opt_$(PROGRAM).s $(LDFLAGS) -Wl,-T,spm.ld
	objdump -d opt_$(PROGRAM) > opt_$(PROGRAM).dis

stack_manager.bc:$(SMMDIR)/stack_manager.c
	$(CC) -I$(SMMDIR) -include stack_manager.h $(CFLAGS) $< -o $@

opt_%.bc: %${source_file_extension}
	$(CC) -I$(SMMDIR) -include stack_manager.h  $(CFLAGS) $< -o $@

prof: $(PROF_OBJECTS)
	llvm-link -o prof_basic_$(PROGRAM).bc $(PROF_OBJECTS)
	opt -O3 -disable-inlining -load /home/jcai/Applications/llvm/build/Debug+Asserts/lib/LLVMStackManagementHelper.so -smmsmh < prof_basic_$(PROGRAM).bc > prof_$(PROGRAM).bc
	llvm-dis < prof_$(PROGRAM).bc > prof_$(PROGRAM).ll
	llc -O3 -o prof_$(PROGRAM).s prof_$(PROGRAM).bc 
	$(CC) -o prof_$(PROGRAM) prof_$(PROGRAM).s $(LDFLAGS)
	./prof_$(PROGRAM) ${arguments} ${infile} > /dev/null
	opt -O3 -disable-inlining -load /home/jcai/Applications/llvm/build/Debug+Asserts/lib/LLVMStackManagementHelper.so -smmsmh < prof_basic_$(PROGRAM).bc > prof_$(PROGRAM).bc
    	
stack_management_helper.bc:$(SMMDIR)/stack_management_helper.c
	$(CC) -I$(SMMDIR) -include stack_management_helper.h $(CFLAGS) $< -o $@

prof_%.bc: %${source_file_extension}
	$(CC) -I$(SMMDIR) -include stack_management_helper.h $(CFLAGS) $< -o $@

callgraph:
	opt -O3 -disable-inlining -dot-callgraph < basic_$(PROGRAM).bc
	dot -Tps callgraph.dot -o basic_$(PROGRAM).ps

clean:
	-rm -rf  $(PROGRAM) opt_$(PROGRAM) prof_$(PROGRAM) *.s *.o *.bc *.ll *.dis *.txt *.dot *.ps *.adpcm
    """

	# Create the linker script for SPM setup
	if (not os.path.isfile("spm.ld")): 
		with open('spm.ld', 'w') as outFile:
			inFile = subprocess.Popen("ld --verbose", stdout=subprocess.PIPE, shell=True).communicate()[0].split("\n")
			i = 0
			while i <  range(len(inFile)):
		    		line = inFile[i]
    				while (line.find("==================================================") == -1):
					i = i+1
					line = inFile[i]
				i = i + 1
    				line = inFile[i]
				while (line.find("==================================================") == -1):
					if line.find("executable_start") != -1:
					  	outFile.write(line.replace("0x400000", "0x000000") + "\n  _spm_begin = .;\n  . = . + 0x100000;\n  _spm_end = .;\n")
					else:
    						outFile.write(line + "\n")
					i = i+1
					line = inFile[i]
				break;

	# Create the makefile using the created linker script
	if (not os.path.isfile("Makefile")): 
		cwd = os.getcwd()
		files = os.listdir(cwd)
		objects = []
		source_file_extension = ""
		for i in range(len(files)):
			(file, extension) = os.path.splitext(files[i])
			if(extension == ".c" or extension == ".cpp" or extension == ".cc"):
				objects.append(file)
				if source_file_extension == "":
					source_file_extension = extension
		objects = list(set(objects))
		original_objects = ""
		opt_objects = ""
		prof_objects = ""
	   	for i in range(len(objects)):
			original_objects = original_objects + objects[i] + ".bc" + " "
			opt_objects = opt_objects + "opt_" + objects[i] + ".bc" + " "
			prof_objects = prof_objects + "prof_" + objects[i] + ".bc" + " "
		# Use the name of current folder as the name of generated executable file
		program = os.path.basename(cwd)
		with open('Makefile', 'w') as f:
			makefile = makefile.replace("${original_objects}", original_objects)
			makefile = makefile.replace("${opt_objects}", opt_objects)
			makefile = makefile.replace("${prof_objects}", prof_objects)
			makefile = makefile.replace("${program}", program)
			makefile = makefile.replace("${source_file_extension}", source_file_extension)
			makefile = makefile.replace("${arguments}", arguments)
			if (infile != ""):
				makefile = makefile.replace("${infile}", "< " + infile)
			else:
				makefile = makefile.replace("${infile}", "")
			f.write(makefile)


# Create runme file for a SMM architecture
def create_smm_runme(arguments="", infile = "", outfile=""):
	program = os.path.basename(os.getcwd())
	# Create a runme file 
	if (not os.path.isfile("runme")):
		with open("runme", "w") as f:
			text = "#!/bin/sh\nSIMDIR=$HOME/Applications/smm_gem5\n$SIMDIR/build/X86/gem5.debug -d m5out/smm -r $SIMDIR/configs/example/se.py --cpu-type=atomic -c " + program
			opt_text = "$SIMDIR/build/X86/gem5.debug -d m5out/opt-smm -r $SIMDIR/configs/example/se.py --cpu-type=atomic -c opt_" + program
			if (arguments != ""):
				text = text + " -o \"" + arguments + "\""
				if outfile == "":
					arguments = arguments.replace("output", "opt_output", 1)
				opt_text = opt_text + " -o \"" + arguments + "\""
			if (infile!= ""):
				text = text + " --input=\"" + infile + "\""
				opt_text = opt_text + " --input=\"" + infile + "\""
			if (outfile != ""):
				text = text + " --output=\"" + outfile + "\""
				opt_text = opt_text + " --output=\"opt_" + outfile + "\""
			f.write(text + "\n")
			f.write(opt_text + "\n")
    		subprocess.Popen("chmod 755 runme", stdout=subprocess.PIPE, shell=True)
		

# Create a makefile for a cache-based architecture
def create_cache_makefile():
	#  Makefile
	makefile = """
PROGRAM = ${program}

INCLUDEDIRS=
INCLUDE=
LIBDIRS=
LIBS = -lm

OBJECTS = ${original_objects}
CC=clang
CFLAGS = $(INCLUDEDIRS) $(INCLUDE) -emit-llvm -c -O3 -fno-inline
LDFLAGS = $(LIBDIRS) $(LIBS) -static

all: $(PROGRAM)

$(PROGRAM): $(OBJECTS)
	llvm-link -o basic_$@.bc $(OBJECTS)
	opt -O3 -disable-inlining < basic_$@.bc > $@.bc
	llvm-dis < $@.bc > $@.ll
	llc -O3 -o $@.s $@.bc
	$(CC) -o $@ $@.s $(LDFLAGS)
	objdump -d $@ > $@.dis

%.bc: %${source_file_extension}
	$(CC) $(CFLAGS) $< -o $@

clean:
	-rm -rf  $(PROGRAM) *.s *.o *.bc *.ll *.dis *.txt *.dot *.ps *.adpcm
    """
	# Create the makefile using the created linker script
	if (not os.path.isfile("Makefile")): 
		cwd = os.getcwd()
		files = os.listdir(cwd)
		objects = []
		source_file_extension = ""
		for i in range(len(files)):
			(file, extension) = os.path.splitext(files[i])
			if(extension == ".c" or extension == ".cpp" or extension == ".cc"):
				objects.append(file)
				if source_file_extension == "":
					source_file_extension = extension
		objects = list(set(objects))
		original_objects = ""
	   	for i in range(len(objects)):
			original_objects = original_objects + " " + objects[i] + ".bc"
		# Use the name of current folder as the name of generated executable file
		program = os.path.basename(cwd)
		with open('Makefile', 'w') as f:
			makefile = makefile.replace("${original_objects}", original_objects)
			makefile = makefile.replace("${program}", program)
			makefile = makefile.replace("${source_file_extension}", source_file_extension)
			f.write(makefile)


def create_cache_runme(arguments="", infile="", output=""):
	program = os.path.basename(os.getcwd())
	# Create a runme script
	if (not os.path.isfile("runme")):
		with open("runme", "w") as f:
			text = "#!/bin/sh\nSIMDIR=$HOME/Applications/smm_cache_gem5\n$SIMDIR/build/X86/gem5.debug -d m5out/cache -r $SIMDIR/configs/example/se.py --cpu-type=atomic --caches -c " + program
			if (arguments != ""):
				text = text + " -o \"" + arguments + "\""
			if (output != ""):
				text = text + " --output=\"" + output + "\""
			f.write(text + "\n")
    		subprocess.Popen("chmod 755 runme", stdout=subprocess.PIPE, shell=True)
		

# Get options
if __name__ == "__main__":
	try:
		opts, args = getopt.getopt(sys.argv[1:], "-h", ["help", "configure-smm", "args=", "input=", "output=", "clean", "configure-cache"]) 
	except getopt.GetoptError as err:
		print str(err)
		sys.exit(2)
	arguments = ""
	infile = ""
	outfile = ""
	config = 0
	for opt, arg in opts:
		if opt in ("-h", "--help"):
			print 'smm --configure-smm --configure-cache --args --input --output --clean'
			sys.exit()
		elif opt in ("--configure-smm"):
			config = 1
		elif opt in ("--configure-cache"):
			config = 2
		elif opt in ("--args"):
			arguments = arg
		elif opt in ("--input"):
			infile = arg
		elif opt in ("--output"):
			outfile = arg
		elif opt in ("--clean"):
			if (os.path.isfile("spm.ld")):
    				subprocess.Popen("rm spm.ld", stdout=subprocess.PIPE, shell=True)
			if (os.path.isfile("Makefile")):
    				subprocess.Popen("rm Makefile", stdout=subprocess.PIPE, shell=True)
			if (os.path.isfile("runme")):
    				subprocess.Popen("rm runme", stdout=subprocess.PIPE, shell=True)
			if (os.path.isdir("m5out")):
    				subprocess.Popen("rm -r m5out", stdout=subprocess.PIPE, shell=True)
		else:
			assert False, "unhandled option"
	if config == 1:
		create_smm_makefile(arguments, infile)
		create_smm_runme(arguments, infile, outfile)
	if config == 2:
		create_cache_makefile()
		create_cache_runme(arguments, infile, outfile)
		
	    
	  	
